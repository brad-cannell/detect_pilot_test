---
title: "Merge MedStar Data With APS Data"
date: "Created: 2016-09-23 <br> Updated: `r Sys.Date()`"
output: 
  html_notebook:
    css: custom-css.css
---

# Table of contents

* [Overview](#overview)   
* [Load packages and data](#load)   
* [Determine which rows are likely to be matches](#find-matches)     
* [Merge matched APS rows back with client data](#merge-client-data)         
* [Merge matched DETECT rows back with MedStar data](#merge-detect-data)    
* [Check incident call numbers reported to MedStar compliance](#check-response)     
* [Appending the MedStar and APS data back together](#append)     
* [Clean appended data - possible matched pairs](#clean-pairs)    
* [Merge with other APS data](#merge-aps)      
* [Save merged data](#save)   


# Overview {#overview}

In this file, we will merge the MedStar data and the APS data that we previously cleaned.

We also check the datasets below for response numbers that were submitted to MedStar's legal compliance department by medics as being associated with a patient they reported to APS for investigation.


# Load packages and data {#load}

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
Sys.setenv(TZ = "US/Central")
```

```{r message=FALSE}
library(tidyverse)
library(bfuncs)
```


## Response ID's from MedStar compliance data

These are the response id numbers that correspond to 911 responses where a report was made to APS during the DETECT pilot phase and MedStar compliance was made aware of the report. 

Data from data_medstar_compliance_01_import.Rmd

```{r}
response_ids <- feather::read_feather("/Volumes/Detect/response_ids.feather")
```

```{r}
about_data(response_ids) # 14 observations and 1 variable
```


## MedStar DETECT data

This is the data that contains MedStar DETECT responses and demographics and health data.

Data from data_medstar_complete_01_merge.Rmd

```{r}
medstar_complete <- feather::read_feather("/Volumes/Detect/medstar_complete.feather")
```

```{r}
about_data(medstar_complete) # 99,309 observations and 57 variables
```


## APS Client data

Demographic information from records of all elder abuse and neglect investigations conducted in MedStar's service area between 2015-09-17 and 2015-11-05. 

Data from data_aps_01_import.Rmd

```{r}
client_data <- feather::read_feather("/Volumes/Detect/client_data.feather")
```

```{r}
about_data(client_data) # 747 observations and 13 variables
```


## APS Allegations data

The [allegations](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_1340.asp#APS_1340) data contains information about the allegation type(s) for each case and the perpetrator (self/other) for each allegation.

Data from data_aps_01_import.Rmd

```{r}
allegations <- feather::read_feather("/Volumes/Detect/allegations.feather")
```

```{r}
about_data(allegations) # 1,051 observations and 4 variables
```


## APS [closure reason](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2800.asp#APS_2900) data

The closure data contains information about the closure reason for each case.

Data from data_aps_01_import.Rmd

```{r}
closure <- feather::read_feather("/Volumes/Detect/closure.feather")
```

```{r}
about_data(closure) # 747 observations and 3 variables
```


## APS [disposition](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2700.asp#APS_2700) data

The disposition data contains information about the disposition for each allegation.

Data from data_aps_01_import.Rmd

```{r}
disposition <- feather::read_feather("/Volumes/Detect/disposition.feather")
```

```{r}
about_data(disposition) # 1,128 observations and 5 variables
```

[top](#top)










# Determine which rows are likely to be matches {#find-matches}

In this first section, we will subset our datasets of interest (client data and medstar complete data) to just the variables we want to match on (name, date of birth). We do this because the [RecordLinkage package](https://cran.r-project.org/web/packages/RecordLinkage/index.html) can't make use of, or "pass through" other variables.

Below, we will use various functions from the [RecordLinkage package](https://cran.r-project.org/web/packages/RecordLinkage/index.html) to find rows in the client data that match rows in the medstar detect data on name and date of birth -- including non-exact matches (e.g. mispelled names, mistyped dates of birth).


## Remove redundant rows from MedStar data

The MedStar data currently has multiple rows for each screening (incident pcr number). This is redundant for the purpose of merging records and slows down RecordLinkage considerably. So, here we are going to reduce the MedStar data to one row for each incident pcr number.

We are also only going to attempt to pair rows where there is a completed DETECT screening. This this link for an explanation: https://github.com/brad-cannell/detect_pilot_test/issues/17

```{r}
medstar_one_row_per_incident_pcr <- medstar_complete %>% 
  group_by(incident_pcr_number) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(detect_data == 1)

about_data(medstar_one_row_per_incident_pcr) # 1,247 observations and 57 variables
```


## Remove redundant rows from APS client data

Each time a report is made to APS about a person by phone or email a unique intake stage number is generated. It's possible for multiple reports to be made about the same person/incident. So, there is also a case number assigned to the victim and the report/group of reports. If more than one victim is reported at once, each is given a separate case number. A single victim may be associated with more than one case. 

Therefore, some case numbers in the client data will have multiple rows that are redundant aside from the intake stage (person who reported). When we match the APS data to the MedStar data below by name, individual people may get matched more than once (i.e., if they were treated by MedStar more than once, investigated by APS more than once, or both). We are fine with that. However, we don’t want people to by matched once per person who made a report.  

Therefore, we are going to reduce the client data to one row for each case number. However, we add those rows back into the data later.

```{r}
client_data_one_row_per_case_num <- client_data %>% 
  group_by(case_num) %>% 
  filter(row_number() == 1) %>% 
  ungroup()

about_data(client_data_one_row_per_case_num) # 679 observations and 13 variables
```


## Subset the variables used for record matching

Create two new data sets (client data compare and medstar compare) that contain only the subset of variables we want to use for linking records between MedStar and APS (i.e., first name, last name, birthdate)

```{r}
client_data_compare <- client_data_one_row_per_case_num %>%
  mutate(
    birth_mnth = lubridate::month(dob),
    birth_day  = lubridate::day(dob),
    birth_year = lubridate::year(dob)) %>%
  select(first_name, last_name, birth_mnth:birth_year)

about_data(client_data_compare) # 679 observations and 5 variables
```

```{r}
medstar_compare <- medstar_one_row_per_incident_pcr %>%
  mutate(
    birth_mnth = lubridate::month(dob),
    birth_day  = lubridate::day(dob),
    birth_year = lubridate::year(dob)) %>%
  select(first_name, last_name, birth_mnth:birth_year)

about_data(medstar_compare) # 1,247 observations and 5 variables
```


## Add string comparitors

> String comparators measure the similarity between strings, usually with a similarity measure in
the range [0, 1], where 0 denotes maximal dissimilarity and 1 equality. This allows ‘fuzzy’ comparison patterns as displayed in the following example.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

Below we Compares each record in data set 1 to each record in data set 2 until all records are compared. For example, id1 - id1, id1-id2, idn-idm. For each pair, a probability match is given for each variable (i.e., first name, last name, etc.). In this case, we are using the Jaro-Winkler distance as our comparison measure ( [Winkler, 1990](http://eric.ed.gov/?id=ED325505), [Wikipedia, 2018](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)).

```{r cache=TRUE}
rpairs_jar <- RecordLinkage::compare.linkage(
  dataset1  = client_data_compare, 
  dataset2  = medstar_compare,
  strcmp    = c("first_name", "last_name")
)
```


## Stochastic record linkage

> Stochastic record linkage relies on the assumption of conditional probabilities concerning comparison patterns... In RecordLinkage an EM algorithm is used as a promising method for reliable estimations. The backbone of this algorithm is described by Haber (1984). Weight calculation based on the EM algorithm
and the method by Contiero et al. (2005) are implemented by functions emWeights and epiWeights. Both take a data set object as argument and return copy with the calculated weights stored in additional components. Calling summary on the result shows the distribution of weights in histogram style. This information can be helpful for determining classification thresholds, e.g. by identifying clusters of record pairs with high or low weights as non-matches or matches respectively.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

This function calculates weights for record pairs based on the approach used by Contiero et al. in the EpiLink record linkage software. [Contiero et al. (2005)](http://methods.schattauer.de/en/contents/archivepremium/manuscript/431.html)

```{r}
rpairs_epiwt <- RecordLinkage::epiWeights(rpairs_jar)
```


## Manually inspect all pairs and their weights

> Discernment between matches and non-matches is achieved by means of computing weight thresholds... The most common practice is to determine thresholds by clerical review, either a single threshold which separates links and non-links or separate thresholds for links and non-links which define a range of doubtable cases between them. RecordLinkage supports this by the function getPairs, which shows record pairs aligned in two consecutive lines along with their weight.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

Review record pairs aligned in two consecutive rows along with their weight (results hidden to protect participant privacy):

```{r eval=FALSE, rows.print=50}
weighted_pairs <- RecordLinkage::getPairs(rpairs_epiwt, max.weight = Inf, min.weight = 0.5)
weighted_pairs
```

When the weight dips below 0.8454956, the matches begin to break down.

```{r}
max_weight <- 0.8454956 - .0001 # Because threshold below is not inclusive
```


## Classification

> When appropriate thresholds are found, classification is performed with emClassify or epiClassify, which take as arguments the data set object and one or two classification thresholds.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

```{r classification}
result <- RecordLinkage::epiClassify(rpairs_epiwt, threshold.upper = max_weight)
```

> The result is an object of class "RecLinkResult", which differs from the data object in having a component prediction that represents the classification result. Calling summary on such an object shows error measures and a table comparing true and predicted matching status [(Sariyar & Borg, 2010)](https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Sariyar+Borg.pdf).

```{r}
summary(result)
```


## Filter for the pairs that were classified as [possible] links, "L"

```{r}
pairs_possible_matches <- RecordLinkage::getPairs(result, show = "links")
```


## Process pairs data for merging back to original data frames

```{r}
pairs_possible_matches <- pairs_possible_matches %>% 
  filter(id != "") %>% # Drop blank rows that are used as separators between pairs
  mutate(
    row  = row_number(), # Create a row number variable
    pair = rep(seq(nrow(.) / 2), each = 2) # Create pair number
  )

about_data(pairs_possible_matches) # 162 observations and 9 variables
```


## Coerce variables from factor to numeric/character as appropriate  

```{r}
pairs_possible_matches <- pairs_possible_matches %>%
  map_at(
    .at = c("id", "birth_mnth", "birth_day", "birth_year", "Weight"),
    .f  = ~ as.numeric(as.character(.))
  ) %>%
  map_at(
    .at = c("first_name", "last_name"),
    .f  = as.character
  )%>% 
  as_tibble()
```


```{r}
if (exists("weighted_pairs")) { # Only created interactively
  rm(weighted_pairs)
}
rm(client_data_compare, medstar_compare, result, rpairs_epiwt, rpairs_jar, max_weight)
```


## Summary

Above, we created two new data sets (client data compare and medstar compare) that contained only the subset of variables we wanted to use for linking records between them. Now that we have an Identifier that links the records, we want to merge it with the original data sets (client data and medstar), which contain the variables that we are actually interested in.

To do this we essentially just want to add the "pair" variable to each dataset where id = row number.

Then merge APS and MedStar data by pair.

[top](#top)










# Merge matched APS rows back with client data {#merge-client-data}

## Subset aps rows from pairs_possible_matches

Remember that aps client data is data1 (first row in pair of rows), and MedStar data is data2 (second row in pair of rows).

The APS rows and MedStar rows can always be relinked using the "pair" variable created above.

```{r}
possible_matches_aps <- pairs_possible_matches %>% filter(row %% 2 == 1)
```


## Create id variable in client data for matching with id variable in possible_matches_aps

Above, when we used the getPairs function, each row in the weighted_pairs data was assigned an id number. That id number corresponds to the row in the original data frame that record came from. For example, the first row of a given pair has id = 28. Because the first row in a pair of rows comes from the client data dataset, and because the id number corresponds to the row in the original dataset, we know that that particular row in the pairs data comes from row 28 of the client data. We can use this to match our pairs back up with the original data.

Additionally, all we really need from the pairs data is the id number (to join with the client data) and the pair number, which will later be used to join the APS data with the MedStar data.

```{r}
client_data_one_row_per_case_num <- client_data_one_row_per_case_num %>% mutate(row_num = row_number())
```

```{r}
possible_matches_aps <- possible_matches_aps %>% select(id, pair)
```


## Add pair variable to client data

```{r}
client_data_one_row_per_case_num <- client_data_one_row_per_case_num %>% 
  left_join(possible_matches_aps, by = c("row_num" = "id"))
```

```{r}
about_data(client_data_one_row_per_case_num) # 703 observations and 15 variables
```

There are more observations in client_data_one_row_per_case_num now than ther were before the join with possible_matches_aps because some people were matched more than once. We will sort out which APS investigation goes with DETECT screening later using dates.


## Check to see if all the pair numbers survived the join

```{r}
sum(!is.na(client_data_one_row_per_case_num$pair)) # 81 - expected number
```

```{r}
rm(possible_matches_aps)
```


## Summary

* We now have a dataset that includes one row for each case number that exists in the APS client data.

* It has a variable called "pair" that contains a number or an NA. 

    - If NA then the first name, last name, and DOB for the person in that row did not match the first name, last name, and DOB for any person found in the MedStar data.
    
    - If a number then the first name, last name, and DOB for the person in that row did match the first name, last name, and DOB for a person found in the MedStar data. This number will later be used to join the APS data to the MedStar data.

[top](#top)










# Merge matched DETECT rows back with MedStar data {#merge-detect-data}

## Subset DETECT rows from pairs_possible_matches

Remember that aps client data is data1 (first row in pair of rows), and MedStar data is data2 (second row in pair of rows).

The APS rows and MedStar rows can always be relinked using the "pair" variable created above.

```{r}
possible_matches_medstar <- pairs_possible_matches %>% filter(row %% 2 == 0)
```


## Create id variable in medstar_detect for matching with id variable in possible_matches_medstar

Above, when we used the getPairs function, each row in the weighted_pairs data was assigned an id number. That id number corresponds to the row in the original data frame that record came from. For example, the second row of a given pair has id = 100. Because the second row in a pair of rows comes from the medstar dataset, and because the id number corresponds to the row in the original dataset, we know that that particular row in the pairs data comes from row 100 of the medstar data. We can use this to match our pairs back up with the original data.

Additionally, all we really need from the pairs data is the id number (to join with the MedStar data) and the pair number, which will later be used to join the MedStar data with the APS data.

```{r}
medstar_one_row_per_incident_pcr <- medstar_one_row_per_incident_pcr %>% mutate(row_num = row_number())
```

```{r}
possible_matches_medstar <- possible_matches_medstar %>% select(id, pair)
```


## Add pair variable to MedStar data

```{r}
medstar_one_row_per_incident_pcr <- medstar_one_row_per_incident_pcr %>% 
  left_join(possible_matches_medstar, by = c("row_num" = "id"))
```

```{r}
about_data(medstar_one_row_per_incident_pcr) # 1,261 observations and 59 variables
```

There are more observations in medstar_one_row_per_incident_pcr now than ther were before the join with possible_matches_medstar because some people were matched more than once. We will sort out which APS investigation goes with DETECT screening later using dates.


## Check to see if all the pair numbers survived the join

```{r}
sum(!is.na(medstar_one_row_per_incident_pcr$pair)) # 81 - expected number
```


## Summary

* We now have a dataset that includes one row for each incident pcr number that exists in the MedStar data.

* It has a variable called "pair" that contains a number or an NA. 

    - If NA then the first name, last name, and DOB for the person in that row did not match the first name, last name, and DOB for any person found in the APS data.
    
    - If a number then the first name, last name, and DOB for the person in that row did match the first name, last name, and DOB for a person found in the APS data. This number will later be used to join the APS data to the MedStar data.

[top](#top)










# Joing MedStar and APS dataset by pair number

```{r}
medstar_one_row_per_incident_pcr %>% 
  left_join(
    client_data_one_row_per_case_num,
    by = "pair",
    suffix = c(".medstar", ".aps")
  )
```

Doesn't work because all the missing pair values join with each other.

```{r}
sum(is.na(medstar_one_row_per_incident_pcr$pair))
```

```{r}
test <- medstar_one_row_per_incident_pcr %>% 
  filter(!is.na(pair)) %>% 
  left_join(
    client_data_one_row_per_case_num %>% 
      filter(!is.na(pair)),
    by = "pair",
    suffix = c(".medstar", ".aps")
  ) %>% 
  select(
    date_entered,
    intake_start,
    case_num,
    starts_with("incident"),
    ends_with(".medstar"),
    ends_with(".aps"),
    pair
  )
```

Pairs just match people -- not screening/investigation combinations, which is what we are really interested in.

For every PCR we only want one pair number, i.e. one matching name/dob combination

```{r}
test %>% 
  group_by(incident_pcr_number) %>% 
  summarise(count_pair = length(unique(pair))) %>% 
  filter(count_pair > 1)
```

Currently, there are several pcr numbers that are associated with more than one pair number. This can happen because the person is treated more than once by medstar, investigated more than once by APS, or both. They will get a separate pair number for each combination of instances in which they appear in the two datasets.

* If the investigation date happened before the screening date then drop

* If there is more than one investigation date after the screening date then keep the closet one

```{r}
test <- test %>% 
  mutate(
    date_entered = as.Date(date_entered),
    intake_start = as.Date(intake_start)
  ) %>% 
  filter(date_entered <= intake_start)
```

How many PCR numbers are associated with more than one pair number?

```{r}
test %>% 
  group_by(incident_pcr_number) %>% 
  summarise(count_pair = length(unique(pair))) %>% 
  filter(count_pair > 1)
```

Check this out further

```{r}
test %>% 
  group_by(incident_pcr_number) %>% 
  mutate(count_pair = length(unique(pair))) %>% 
  ungroup() %>% 
  filter(count_pair > 1)
```

So, just keep the closest investigation

```{r}
test <- test %>% 
  arrange(incident_pcr_number, intake_start) %>% 
  group_by(incident_pcr_number) %>% 
  filter(row_number() == 1) %>% 
  ungroup()
```

```{r}
test %>% 
  group_by(incident_pcr_number) %>% 
  summarise(count_pair = length(unique(pair))) %>% 
  filter(count_pair > 1)
```

Now, each pcr number is associated with one or none aps investigations. If should only be none if no report was ever made to APS.

```{r}
about_data(test)
```


Create a key

```{r}
key <- test %>% select(pair, incident_pcr_number, case_num)
key
```

Add pair to medstar complete

```{r}
medstar_test <- medstar_complete %>% 
  left_join(key %>% select(pair, incident_pcr_number), by = "incident_pcr_number")
```

```{r}
medstar_test %>% 
  filter(!is.na(pair)) %>% 
  pull(pair) %>% 
  unique() %>% 
  length()
```


Add pair to client data

```{r}
client_data_test <- client_data %>% 
  left_join(key %>% select(pair, case_num), by = "case_num")
```

```{r}
client_data_test %>% 
  filter(!is.na(pair)) %>% 
  pull(pair) %>% 
  unique() %>% 
  length()
```

merge medstar and client data on pair - ignoring NA

```{r}
merge_test <- medstar_test %>% 
  left_join(client_data_test, by = "pair", na_matches = "never")
```


Then do some manual checks to make sure it worked correctly.













# Check incident call numbers reported to MedStar compliance {#check-response}

Check to see if all the response numbers from the MedStar compliance data exist in the medstar with pair data.  

```{r}
about_data(response_ids) # 14 observations and 1 variables
```


anti_join returns all rows in MedStar's legal compliance data that do not have a match in the MedStar DETECT screening items data that was matched to APS cases (results hidden to protect participant privacy).

```{r}
response_ids %>% 
  anti_join(medstar_one_row_per_incident_pcr, by = c("response_num" = "incident_call_number")) %>%  
  unique() # 5 incident call numbers
```

Previously, there were 6 responses id's in the MedStar compliance data that don't appear in the MedStar DETECT screening items data and now there are 5 response id's in the MedStar compliance data that don't appear in the MedStar complete data (results hidden to protect participant privacy). 

I have an email from MedStar from 2016-10-10 outlining the discrepancy. One response id had all nulls for the DETECT screening items. One response id could not be found in the query. The rest were ineligible for the DETECT screening tool because of age.

The person that had all nulls for the DETECT screening items, and didn't appear in the DETECT data, does appear in this data because they had a record in the MedStar demogaphics and health data. However, they still have no DETECT screening information.

At this point, there should be 9 response id's from the compliance data that have a match in the complete MedStar data (results hidden to protect participant privacy).


```{r eval=FALSE}
response_ids %>% 
  semi_join(medstar_one_row_per_incident_pcr, by = c("response_num" = "incident_call_number")) %>% 
  unique() # 9 incident call numbers
```



There is 1 (not 2) incident call numbers that appear in Medstar's legal compliance data, but not in the MedStar DETECT data. So, incident call number 1138 is in the compliance data. It's also in the medstar_detect data. But, it is not in the medstar detect data that was paired with APS data.

Now we inspect the full record for incident call number 1138 (results hidden to protect participant privacy). After inspection (code was deleted to protect participant privacy), it appears as though that person had a Dallas address. I also checked our APS data manually for that person's name. So, it appears as though the medic provided service in Dallas, completed a DETECT screening for that person, made a report to APS, and came back to MedStar and made the legal compliance department aware of the report to APS. However, because the data we received from APS does not include Dallas county, we are unable to pair that DETECT screening with an APS investigation.


## Count how many times those response numbers appear

Count how many times (i.e., repeats) the 7 response numbers from above appear in the MedStar DETECT screening items data that was matched to APS cases.

semi_join returns all rows in MedStar's legal compliance data that have a match in the MedStar DETECT screening items data that was matched to APS cases (results hidden to protect participant privacy).

```{r}
# medstar_detect_w_pair %>% 
#   filter(
#     incident_call_number %in% (
#       medstar_compliance_deidentified %>% 
#         semi_join(medstar_detect_w_pair, by = "incident_call_number") %>% 
#         pull(incident_call_number)
#     )
#   ) %>% 
#   arrange(incident_call_number) %>% 
#   summarise(
#     `Unique Numbers` = unique(incident_call_number) %>% length(), # 7
#     `Total Rows`     = n() # 11
#   )
```


## Add compliance indicator variable

Add a variable to the data to indicate if the response number in each row was also in the MedStar legal compliance data.

```{r}
# medstar_detect_w_pair <- medstar_detect_w_pair %>% 
#   mutate(
#     compliance_match = incident_call_number %in% 
#       pull(medstar_compliance_deidentified, incident_call_number)
#   )
# 
# about_data(medstar_detect_w_pair) # 132 observations and 47 variables
```

```{r}
# rm(medstar_compliance_deidentified)
```


## Summary

There are 2 incident call numbers in the MedStar compliance data that don't appear in the MedStar DETECT screening items data that was matched to APS cases. According to an email from MedStar from 2016-10-10, one incident call number (1882) had all nulls for the DETECT screening items. After inspection, it appears as though the other incident call number (1138) had a Dallas address.

As expected, there are 7 matching response numbers in the MedStar DETECT screening items data that was matched to APS cases. However, those response numbers appear in 11 different rows. I manually inspected those rows and found two response numbers that appear twice and one response number that appears three times. We filter out duplicates below.

[top](#top)










# Appending the MedStar and APS data back together {#append}

So far, we have:

* Found records in the MedStar DETECT screening data that have a match - based on name and date of birth - in the APS client data. But, this matched data only contained name and date of birth information.

* We gave each pair of those matching records a unique pair number (pairs_possible_matches)

* We split the paired data into two datasets: records that came from the MedStar data (possible_matches_medstar) and records that came from the APS data (possible_matches_aps).

* We then merged the records that have a match in the other dataset with variables of substantive interest from the original data those records came from -- retaining the unique pair number (medstar_detect_w_pair & client_data_w_pair).

In this section, we want to bind medstar_detect_w_pair & client_data_w_pair back into a single data frame.


## Append and then sort by row.

```{r}
append_aps_detect_w_pair <- medstar_detect_w_pair %>% 
  bind_rows(client_data_w_pair) %>% 
  arrange(row)

about_data(append_aps_detect_w_pair) # 264 observations and 51 variables
```


## Set all NULL values to NA   

```{r to_na}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>%
  # Null to NA
  map_if(
    .p = is.character, 
    .f = function(x) {
      x[x == "NULL"] <- NA 
      x
    }
  ) %>%
  as_tibble()
```


## Share info between rows (between the MedStar and APS data)

1. Carry forward APS info into the even (medstar detect data) rows    
2. Carry backward medstar response date into the odd (APS client info) rows   


### Is there missingness in key variables that we need to worry about?

```{r}
sum(is.na(client_data$case_num))
sum(is.na(client_data$intake_stage))
sum(is.na(client_data$intake_start))
sum(is.na(medstar_detect$response_date))
```


## No missing - perform na.locf

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  map_at(
    .at = c("case_num", "intake_stage", "intake_start", "county"), 
    .f = zoo::na.locf
  ) %>%
  map_at(
    .at = c("Weight", "response_num", "response_date", "compliance_match"), 
    .f = zoo::na.locf, fromLast = TRUE
  ) %>% 
  as_tibble()

about_data(append_aps_detect_w_pair) # 264 observations and 51 variables
```

```{r}
rm(client_data_w_pair, medstar_detect_w_pair)
```


## Summary

We now have a single data frame, append_aps_detect_w_pair, that contains possible matched pairs of rows (on name and date of birth) from the APS client data and the MedStar DETECT screening data. 

Next, we will do a more thorough check of the possible matched pairs. We will make sure that they are actually matched pairs, and that they are not duplicates.

[top](#top)










# Clean appended data - possible matched pairs {#clean-pairs}

We now have a single data frame, append_aps_detect_w_pair, that contains possible matched pairs of rows (on name and date of birth) from the APS client data and the MedStar DETECT screening data. 

Next, we will do a more thorough check of the possible matched pairs. We will make sure that they are actually matched pairs, and that they are not duplicates.


## Manually inspect all pairs with weight < 1.0 (Not a perfect match) 

(results hidden to protect participant privacy)

```{r eval=FALSE}
append_aps_detect_w_pair %>% 
  filter(Weight < 1)
```

After manual inspection, the last true match has a weight of 0.8320895. Will drop all rows with a weight < 0.8320895.

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  filter(Weight >= 0.8320895)

about_data(append_aps_detect_w_pair) # 182 observations and 51 variables
```


## How many DETECT screenings have a match in the APS outcomes data?

```{r}
append_aps_detect_w_pair %>% 
  filter(row_number() %% 2 == 1) %>% # Keep only the MedStar rows
  distinct(id) %>% 
  nrow()
```


## How many compliance data matches remain?

```{r}
append_aps_detect_w_pair %>% 
  group_by(compliance_match) %>% 
  summarise(n()) # 22 as expected
```


## Reporting order

* **response_date** is when MedStar responded to the 911 call. 

* **intake_start** is when APS started the intake. 

Logically, the response_date must be before the intake_start in order for the DETECT tool to have predicted abuse. Take a look at matches where the opposite is true (results hidden to protect participant privacy).

```{r eval=FALSE}
append_aps_detect_w_pair %>% 
  filter(response_date > intake_start) # 70 rows
```


## Check response numbers

Check to see if any of the response numbers from the MedStar compliance data exist in the data that will be dropped. 

```{r}
append_aps_detect_w_pair %>% 
  filter(response_date > intake_start) %>% 
  group_by(compliance_match) %>% 
  summarise(n())
```

None of the response id numbers from the MedStar compliance data are among the records that will be dropped because of reporting order. I also checked the data manually. aps_report_num is NA in all rows of temp.


## Drop pairs when MedStar response date is after APS intake date  

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  filter(response_date <= intake_start)

about_data(append_aps_detect_w_pair) # 112 observations and 51 variables
```

* Updated on 2017-01-28: changed from response_date < intake_start to response_date <= intake_start. Remember, intake_start is just APS receiving a report.


## Time to intake

Calculate time between response date and intake

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  mutate(time_diff = difftime(intake_start, response_date, units = "days"))

about_data(append_aps_detect_w_pair) # 112 observations and 52 variables
```


## Create two new variables to retain the MedStar and APS ID's

In the past I dropped these. Decided to keep them in order to better understand where the rows in my final analysis come from.

Remember that aps client data is data1 (first row in pair of rows), and MedStar data is data2 (second row in pair of rows).

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  group_by(pair) %>% 
  mutate(
    msid  = ifelse(row %% 2 == 0, id, NA),
    apsid = ifelse(row %% 2 == 1, id, NA),
    msid  = zoo::na.locf(msid, fromLast = TRUE),
    apsid = zoo::na.locf(apsid)
  ) %>% 
  ungroup()

about_data(append_aps_detect_w_pair) # 112 observations and 54 variables
```


Double-checked. msid and apsid were carried forward correctly. I also checked to make sure that the do, in fact, correspond the the row numbers of the original medstar and client_data data frames.


## Drop the id column and move msid and apsid to the front of the tibble

```{r}
append_aps_detect_w_pair <- append_aps_detect_w_pair %>% 
  select(msid, apsid, row, pair, everything(), -id)

about_data(append_aps_detect_w_pair) # 112 observations and 53 variables
```


## Collapse rows

Even rows (MedStar rows) contain all the APS information. So, just keep the even rows.

```{r}
append_aps_detect <- append_aps_detect_w_pair %>% 
  filter(row %% 2 == 0)

about_data(append_aps_detect) # 56 observations and 53 variables
```


## Make sure that each row is unique to a person / DETECT screening date

![](../images/aps_identifiers.png)

* **Case number definition**: APS case / investigation number.

* **Intake stage definition**: That's an ID number assigned to the Intake. Each Intake (Report to APS) has its own number. A single case may have more than one intake. For example, on the first tab of the spreadsheet, you can see that case # XXXXXX has two intakes associated with it, 9 days apart, each with their own ID number. On the second tab of the spreadsheet, which provides allegations associated with each intake, you can see that each of the two intakes associated with this case have a number of allegations.

* **Intake start definition**: An intake is the submission or receipt of a report of abuse - a phone call or web-based. The Intake Start Date refers to the date the staff member opens a new record to begin recording the report. In the case of a phone call they have picked up from a caller on the abuse hotline, the intake starts when the Intake worker begins to speak to the individual, open the record and begin recording what they are hearing. In the case of reports made using the web-based system, intake begins when the Intake worker pulls the web-report and begins processing it in the system. There is the possibility that the intake may begin on one day but not end until the next day.

![](../images/medstar_detect_identifiers.png)

* **Incident call number** is unique to the incident/respnse (#2 in the diagram). In cases where there was more than one person screened at an incident/response, the response number is not unique to the person/screening (#3 and #4 in the diagram).
    
* **Incident PCR number** is unique to the person/DETECT screening at a given incident/response. NOTE: No two people should have the same incident PCR number; however, a single person may have multiple incident PCR numbers if they were treated by MedStar on multiple occasions.

* **Response date definition**: Day that MedStar ran the 911 call and filled out the DETECT screening tool.

If a row is unique to a person / DETECT screening date, then the incident PCR number should be unique.

```{r}
append_aps_detect %>% 
  select(incident_pcr_number, everything()) %>% 
  arrange(incident_pcr_number) %>% 
  group_by(incident_pcr_number) %>% 
  mutate(count = row_number() %>% max()) %>% 
  filter(count > 1) %>% # Stop here to view duplicates
  summarise(Duplicates = duplicated(incident_pcr_number) %>% sum()) %>% 
  ungroup() %>% 
  summarise(
    `Duplicate PCR Numbers`  = n(), # 9
    `Duplicate Rows`         = sum(Duplicates) # 10
  ) 
```

There are 9 incident PCR numbers that appear in more than one row. One combination appears in three rows (2 duplicates) for a total of 10 rows with a duplicated combination (19 rows total). Investigate these manually.


## Rules for dropping duplicates

In this context, duplicates are in terms of person and response date (date DETECT screening tool was used). These may arise for a number of reasons. In general, we have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, our goal is to retain one row for each DETECT screening, and pair it with the corresponding APS investigation (on the same person, of course) that was temporally closest to the screening.

1. If two DETECT screenings are completed for the same person in a single day, then that person will have two records in the MedStar data with identical response dates. However, they aren't really duplicates. They are two different screenings, potentially completed by two different people. The predictive performance of both screenings should be analyzed.

2. For any given screening in the MedStar data that was matched to multiple investigations (on the same person, of course) in the APS data, we keep the row with the shortest amount of time between screening and intake_start.

3. When two rows differ only by intake stage, it means that there was one MedStar screening and one APS investigation, but the investigation was prompted by two or more separate reports. Therefore, one row is simply duplicate information, and retaining both would essentially up weight the influence of that particular screening / outcome combination. Choosing the row to drop is arbitrary. For consistency, we will always drop the second row.


## Application of the dropping rules in this data

* Rows 8 and 10 only differ by intake stage. Row 10 will be dropped.

* For rows 112 and 126 one DETECT screening was matched with two different APS investigations (incident call numbers). We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 126.

* Rows 84 and 86 only differ by intake stage. Row 86 will be dropped.

* For rows 88 and 156 one DETECT screening was matched with two different APS investigations (incident call numbers). We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 156.

* Rows 106 and 108 only differ by intake stage. Row 108 will be dropped.

* For rows 110 and 124 one DETECT screening was matched with two different APS investigations (incident call numbers). We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 124.

* Rows 114, 116 and 118 only differ by intake stage. Rows 116 and 118 will be dropped.

* Rows 4 and 6 only differ by intake stage. Row 6 will be dropped.

* Rows 134 and 136 only differ by intake stage. Row 136 will be dropped.


## Drop duplicate rows and the compare variable

```{r}
append_aps_detect <- append_aps_detect %>% 
  filter(!(row %in% c(6, 126, 124, 86, 10, 156, 136, 108, 116, 118)))

about_data(append_aps_detect) # 46 observations and 53 variables
```


## Final manual inspection   

1. Visually inspect rows for a match   
2. Make sure that each pair is unique to a person / DETECT screening date 

There are still people who appear in the data more than once. However, they these people have a separate DETECT screening associated with each of their records. 

We don't know which DETECT screening (if any) was the cause of the APS investigation it's being linked with. Currently, this isn't really an issue because we aren't using this data to determine if DETECT is increasing reports or not. We are getting that information from MedStar compliance. With this data, we are simply evaluating whether or not a "yes" response on any given screening is predictive of a valid investigation - regardless of the report that initiated it.

The data we currently have meets that criteria. We have a completed DETECT screening. That DETECT screening is paired with an APS investigation for the same person, which was carried out shortly after the DETECT screening occurred.

It's still possible that our analysis data could be dominated by results from just a handful of people. We will have to check the records we end up using in the final analysis.


## Are all 7 of the compliance cases still in the data?

```{r}
append_aps_detect %>% 
  group_by(compliance_match) %>% 
  summarise(n())
```

```{r}
rm(append_aps_detect_w_pair)
```


## Summary

In the section above we:

* Manually inspected the possible matched pairs of records. The last true match had a weight of 0.8320895. We dropped all rows with a weight < 0.8320895.

* Logically, the response_date must be before the intake_start in order for the DETECT tool to have predicted abuse. So, we dropped all records with a response_date (MedStar) > the intake_start date (APS).

* At that point, both rows of data in each pair of records had identical data. Therefore, we kept only one row from each pair.

* Finally, we removed duplicate rows (in terms of name and response date) using rules described at length above.

We now have a single data frame (46 observations and 52 variables), append_aps_detect, that contains APS client data matched to MedStar DETECT screenings on name and date of birth.

[top](#top)










# Merge with other APS data {#merge-aps}

How many unique case numbers are in the APS client data matched to MedStar DETECT screenings on name and date of birth?

```{r}
append_aps_detect %>% 
  summarise(`Unique Cases` = unique(case_num) %>% length()) # 41
```


## For easier visual inspection, just keep the case numbers of interest

```{r}
allegations_subset <- allegations %>% 
  filter(case_num %in% pull(append_aps_detect, case_num))

about_data(allegations_subset) # 66 observations and 4 variables
```

```{r}
closure_subset <- closure %>% 
  filter(case_num %in% pull(append_aps_detect, case_num))

about_data(closure_subset) # 50 observations and 3 variables
```

```{r}
disposition_subset <- disposition %>% 
  filter(case_num %in% pull(append_aps_detect, case_num))

about_data(disposition_subset) # 61 observations and 5 variables
```

```{r}
rm(allegations, closure, disposition)
```

First, we filtered out case numbers that didn't match case numbers in the APS client data matched to MedStar DETECT screenings on name and date of birth (41 unique case numbers). 

Before merging there were 66 rows in the allegations data, 50 rows in the closure data, and 61 rows in the disposition data. Some cases include more than one allegation. They may also include multiple intakes/reporters, and perpetrators. 

1. **Allegations** contains a row for each combination of case number, intake stage (reporter), allegation and perpetrator.    

2. **Disposition** contains a row for each combination of case number, allegation, and perpetrator, but does not differentiate between intake stage numbers (reporter).   

3. **Closure** contains a row for each combination of case number and intake stage; however, the actual closure reason is constant across rows within case number.    

For the purposes of the current analysis we aren’t so concerned with who reported the abuse. Ultimately, we do want EMTs to report more often when appropriate; however, the aim of the current analysis is just to investigate the predictive performance of the screening items. We are just concerned with whether or not the tool accurately predicted abuse - regardless of who reported it.

Therefore, we will drop all rows in allegation that only differ by intake stage. This will make for a cleaner merge below.


## Drop intake_stage and perp_id

```{r}
allegations_subset <- allegations_subset %>% select(case_num, allegation, perp)
about_data(allegations_subset) # 66 observations and 3 variables
```


## Remove duplicate rows

```{r}
allegations_subset <- distinct(allegations_subset)
about_data(allegations_subset) # 57 observations and 3 variables
```


## Allegations at intake vs. allegations at investigation

APS writes of the difference between allegation at intake (in the allegations file) and allegations at investigation (in the disposition file):

> At the time of intake, the intake worker will listen to the allegations and categorize them based on what they are hearing from the caller. Once the investigator gets involved and begins work on the case, they may revise or more often add to the allegations as they flesh out the situation. As they investigate, they often discover new allegations relevant to the case. There has to be a unique allegation for every perpetrator, so as the investigation proceeds and more than one perpetrator may be involved (including self-- very often both self-neglect and ANE by another are co-occurring), the number of allegations per case can multiply.

Next, we will check to make sure that all allegations (at intake and at investigation) are retained, and that they have a corresponding disposition and closure reason.

```{r}
check <- left_join(allegations_subset, disposition_subset, by = c("case_num"))

# Are there any cases of an allegation/perpetrator in allegation.x/perp.x that doesn't exist in allegation.y/perp.y?
check2 <- check %>% 
  group_by(case_num) %>%
  mutate(
    combox = paste0(allegation.x, perp.x),
    comboy = paste0(allegation.y, perp.y),
    xiny   = ifelse(combox %in% comboy, TRUE, FALSE)
  )

# All say true. Just to make sure it's doing what I think it should be doing, I'm going to embed a fake value.
# check3 <- check
# check3[4, 2] <- "Exploitation" 
# check4 <- check3 %>% 
#   group_by(case_num) %>%
#   mutate(
#     combox = paste0(allegation.x, perp.x),
#     comboy = paste0(allegation.y, perp.y),
#     xiny   = ifelse(combox %in% comboy, TRUE, FALSE)
#   )
# Works as expected
rm(check, check2)
cat("Done")
```

After data checks:  

1. Must do a left_join on case number only. Otherwise, allegations at investigation (from disposition) are lost.     

2. After left join, allegation.x and perp.x no longer contain any unique information and can be dropped.    
3. Finally, we need to clean up the data by renaming allegation.y and perp.y, and dropping duplicate rows.


## Merge [allegations](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_1340.asp#APS_1340) and [disposition](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2700.asp#APS_2700)

```{r}
ad <- left_join(allegations_subset, disposition_subset, by = c("case_num")) %>%
  mutate(
    allegation.x = NULL, 
    perp.x = NULL) %>%
  rename(
    allegation = allegation.y,
    perp = perp.y) %>%
  distinct

about_data(ad) # 61 observations and 5 variables 
```


## Merge with [closure reason](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2800.asp#APS_2900)

```{r}
# Remove intake stage
closure_subset <- closure_subset[, -2]

# Remove duplicate rows (There is only one closure reason per case number)
closure_subset <- distinct(closure_subset)

# Join
adc <- left_join(ad, closure_subset, by = "case_num")

about_data(adc) # 61 observations and 6 variables in the data
```


## Merge with linked MedStar and client data

In some cases there are multiple rows per case number. In all of those cases it's because of differing response numbers / dates. In other words, MedStar completed DETECT on a person more than once, but they were close enough to each other in time, that APS only performed one investigation. In those cases, we will keep both rows.

```{r}
merged <- left_join(append_aps_detect, adc, by = "case_num")

# Look for duplicate rows
sum(duplicated(merged)) # None
```

```{r}
about_data(merged) # 67 observations and 58 variables
```


## Total unique matched records

We just added a bunch of extra rows to the data (multiple allegations, perps, etc.). However, we should still have the same number of unique pairs the APS client data matched to MedStar DETECT screenings on name and date of birth.

```{r}
append_aps_detect %>% summarise(`Unique Pair` = unique(pair) %>% length) # 46
```

```{r}
merged %>% summarise(`Unique Pair` = unique(pair) %>% length) # 46
```


## Are all 7 of the compliance cases still in the data?

```{r}
merged %>% 
  filter(compliance_match == 1) %>% 
  summarise(`Compliance Cases` = unique(pair) %>% length())
```


## Coerce selected character vectors to factors   

To improve readability of codebook

```{r to_factor}
merged <- merged %>%
  map_at(
    .at = c("msid", "apsid", "row", "pair", "birth_month", "birth_day", "birth_year", "Weight", 
            "incident_call_number", "incident_pcr_number", "case_num", "intake_stage", "zip",
            "aps_report_num", "allegation", "perp", "disposition", "closure_reason"),
    .f = factor
  ) %>%
  as_tibble()
```

```{r}
rm(ad, adc, allegations_subset, append_aps_detect, client_data, closure_subset, 
   disposition_subset, medstar_detect)
```


## Summary

In the section above we joined the APS allegations data, APS closure reason data, and APS allegation dispositions data with the single data frame (46 observations and 52 variables), append_aps_detect, that contained APS client data matched to MedStar DETECT screenings on name and date of birth. This new data frame is called merged.

[top](#top)










# Save the merged MedStar datasets {#save}

```{r}
feather::write_feather(merged, path = "/Volumes/Detect/merged.feather")
```

## References 

Contiero, P., Tittarelli, A., Tagliabue, G., Maghini, A., Fabiano, S., Crosignani, P., & Tessandori, R. (2005). The EpiLink Record Linkage Software Presentation and Results of Linkage Test on Cancer Registry Files. Methods Archive, 44(1), 66-71.

Sariyar, M., & Borg, A. (2010). The RecordLinkage package: Detecting errors in data. The R Journal, 2(2), 61-67.

Winkler, W. (1990). String comparator metrics and enhanced decision rules in the Fellegi-Sunter model of record linkage. Available from http://eric.ed.gov/?id=ED325505.

[top](#top)

&nbsp;

-------------------------------------------------------------------------------

```{r echo=FALSE}
sessionInfo()
```