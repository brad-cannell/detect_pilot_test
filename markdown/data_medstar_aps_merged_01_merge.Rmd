---
title: "Merge MedStar Data With APS Data"
date: "Created: 2016-09-23 <br> Updated: `r Sys.Date()`"
output: 
  html_notebook:
    css: custom-css.css
---

# Table of contents

* [Overview](#overview)   
* [Load packages and data](#load)   
* [Prepare MedStar data for record matching](#prep-medstar)    
* [Prepare APS data for record matching](#prep-aps)    
* [Determine which rows are likely to be matches](#find-matches)     
* [Filter matches using dates](#filter-dates)   
* [Add pair numbers to nested data](#add-pair)   
* [Join MedStar and APS on pair_num](#join-medstar-aps)   
* [Check incident call numbers reported to MedStar compliance](#check-response)     
* [Make sure that each row is unique to a person / DETECT screening date](#unique-rows)   
* [Merge with other APS data](#merge-aps)      
* [Save merged data](#save)   


# Overview {#overview}

In this file, we will merge the MedStar data and the APS data that we previously cleaned.

We also check the datasets below for response numbers that were submitted to MedStar's legal compliance department by medics as being associated with a patient they reported to APS for investigation.


# Load packages and data {#load}

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA)
Sys.setenv(TZ = "US/Central")
```

```{r message=FALSE}
library(tidyverse)
library(bfuncs)
```


## Response ID's from MedStar compliance data

These are the response id numbers that correspond to 911 responses where a report was made to APS during the DETECT pilot phase and MedStar compliance was made aware of the report. 

Data from data_medstar_compliance_01_import.Rmd

```{r}
response_ids <- feather::read_feather("/Volumes/Detect/response_ids.feather")
```

```{r}
about_data(response_ids) # 14 observations and 1 variable
```


## MedStar DETECT data

This is the data that contains MedStar DETECT responses and demographics and health data.

Data from data_medstar_complete_01_merge.Rmd

```{r}
medstar_complete <- feather::read_feather("/Volumes/Detect/medstar_complete.feather")
```

```{r}
about_data(medstar_complete) # 99,309 observations and 57 variables
```


## APS Client data

Demographic information from records of all elder abuse and neglect investigations conducted in MedStar's service area between 2015-09-17 and 2015-11-05. 

Data from data_aps_01_import.Rmd

```{r}
client_data <- feather::read_feather("/Volumes/Detect/client_data.feather")
```

```{r}
about_data(client_data) # 747 observations and 13 variables
```


## APS Allegations data

The [allegations](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_1340.asp#APS_1340) data contains information about the allegation type(s) for each case and the perpetrator (self/other) for each allegation.

Data from data_aps_01_import.Rmd

```{r}
allegations <- feather::read_feather("/Volumes/Detect/allegations.feather")
```

```{r}
about_data(allegations) # 1,051 observations and 4 variables
```


## APS [closure reason](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2800.asp#APS_2900) data

The closure data contains information about the closure reason for each case.

Data from data_aps_01_import.Rmd

```{r}
closure <- feather::read_feather("/Volumes/Detect/closure.feather")
```

```{r}
about_data(closure) # 747 observations and 3 variables
```


## APS [disposition](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2700.asp#APS_2700) data

The disposition data contains information about the disposition for each allegation.

Data from data_aps_01_import.Rmd

```{r}
disposition <- feather::read_feather("/Volumes/Detect/disposition.feather")
```

```{r}
about_data(disposition) # 1,128 observations and 5 variables
```

[top](#top)










# Prepare MedStar data for record matching {#prep-medstar}

The MedStar data currently has multiple rows for each screening (incident pcr number). This is redundant for the purpose of merging records and slows down RecordLinkage considerably. So, here we are going to reduce the MedStar data to one row for each incident pcr number by nesting all other variables.

We are also ONLY going to attempt to pair rows where there is a completed DETECT screening. This this link for an explanation: https://github.com/brad-cannell/detect_pilot_test/issues/17.

```{r}
medstar_nested <- medstar_complete %>% 
  
  # Only keep rows that correspond to a DETECT screening
  filter(detect_data == 1) %>% 
  
  # Separate DOB into its component parts
  mutate(
    birth_mnth = lubridate::month(dob),
    birth_day  = lubridate::day(dob),
    birth_year = lubridate::year(dob)
  ) %>% 
  
  # Nest columns that aren't needed for the RecordLinkage process
  nest(-date_entered, -incident_pcr_number, -first_name, -last_name, -starts_with("birth"), 
       .key = "medstar_nested") %>% 
  
  # Ungroup
  ungroup()
```

## Data check: How many rows are there and how many unique incident PCR numbers are there?

```{r}
medstar_nested %>% 
  summarise(
    Rows = n(),                                        # 1,248
    `Unique PCR` = length(unique(incident_pcr_number)) # 1,247
  )
```

That means that one PCR is duplicated. Below we manually check for differences (results hidden to protect patient privacy).

```{r eval=FALSE}
medstar_nested %>%
  group_by(incident_pcr_number) %>%
  filter(max(row_number()) == 2) %>%
  unnest() %>%
  bfuncs::widen_columns(crew_member_id, medical_surgery_hist, current_meds) %>%
  summarise_all(.funs = funs(unique(.) %>% length())) %>%
  select_if(.predicate = function(x) x > 1)
```

The only difference is the data entered. We have confirmation from MedStar that this can sometimes happen when someone updates the record in the ePCR. We will keep the earliest record only. Keep in mind that nothing else about the two records differs.

```{r}
medstar_nested <- medstar_nested %>% 
  group_by(incident_pcr_number) %>% 
  filter(row_number() == 1) %>% 
  ungroup()
```

```{r}
about_data(medstar_nested) # 1,247 observations and 8 variables
```

At this point each screening (incident_pcr_number) is a single row that can be matched to rows in the APS data.

[top](#top)










# Prepare APS data for record matching {#prep-aps}

Each time a report is made to APS about a person by phone or email a unique intake stage number is generated. It's possible for multiple reports to be made about the same person/incident. So, there is also a case number assigned to the victim and the report/group of reports. If more than one victim is reported at once, each is given a separate case number. A single victim may be associated with more than one case. 

Therefore, some case numbers in the client data will have multiple rows that are redundant aside from the intake stage (person who reported). When we match the APS data to the MedStar data below by name, individual people may get matched more than once (i.e., if they were treated by MedStar more than once, investigated by APS more than once, or both). We are fine with that. However, we don’t want people to be matched once per person who made a report (intake_stage).  

Again, we will get around this by nesting all columns that may result in multiple rows per case number.

```{r}
client_data_nested <- client_data %>% 
  mutate(
    birth_mnth = lubridate::month(dob),
    birth_day  = lubridate::day(dob),
    birth_year = lubridate::year(dob)
  ) %>% 
  nest(-case_num, -intake_start, -first_name, -last_name, -starts_with("birth"), .key = "aps_nested")
```


### Data check: How many rows are there and how many unique case numbers are there?

```{r}
client_data_nested %>% 
  summarise(
    Rows = n(),                               # 730
    `Unique Cases` = length(unique(case_num)) # 679
  )
```

That means that some case numbers are duplicated. Below we manually check for differences (results hidden to protect patient privacy).

```{r eval=FALSE}
client_data_nested %>% 
  group_by(case_num) %>% 
  filter(max(row_number()) > 1) %>% 
  unnest()
```

After manual review, duplicates within case are due to different intake start dates (i.e., report dates), different spellings of names at different intakes (reports). There are also a couple differences in DOB between intakes. We should keep both spellings and DOB's for the matching process. We can filter them later as needed.

[top](#top)










# Determine which rows are likely to be matches {#find-matches}

Below, we will use various functions from the [RecordLinkage package](https://cran.r-project.org/web/packages/RecordLinkage/index.html) to find rows in the client data that match rows in the medstar detect data on name and date of birth -- including non-exact matches (e.g. mispelled names, mistyped dates of birth).

## Subset matching variables

```{r}
medstar_compare <- medstar_nested %>% 
  select(-medstar_nested)

client_data_compare <- client_data_nested %>% 
  select(-aps_nested) %>% 
  select(intake_start, case_num, everything()) # This just make the rows match up below
```

```{r}
ncol(medstar_compare) == ncol(client_data_compare)
```


## Add string comparators

> String comparators measure the similarity between strings, usually with a similarity measure in
the range [0, 1], where 0 denotes maximal dissimilarity and 1 equality. This allows ‘fuzzy’ comparison patterns as displayed in the following example.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

Below we Compares each record in data set 1 to each record in data set 2 until all records are compared. For example, id1 - id1, id1-id2, idn-idm. For each pair, a probability match is given for each variable (i.e., first name, last name, etc.). In this case, we are using the Jaro-Winkler distance as our comparison measure ( [Winkler, 1990](http://eric.ed.gov/?id=ED325505), [Wikipedia, 2018](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance)).

```{r}
rpairs_jar <- RecordLinkage::compare.linkage(
  dataset1  = medstar_compare, 
  dataset2  = client_data_compare,
  strcmp    = c("first_name", "last_name"),
  exclude   = c("incident_pcr_number", "date_entered") # Only uses the names from dataset1
)
```


## Stochastic record linkage

> Stochastic record linkage relies on the assumption of conditional probabilities concerning comparison patterns... In RecordLinkage an EM algorithm is used as a promising method for reliable estimations. The backbone of this algorithm is described by Haber (1984). Weight calculation based on the EM algorithm
and the method by Contiero et al. (2005) are implemented by functions emWeights and epiWeights. Both take a data set object as argument and return copy with the calculated weights stored in additional components. Calling summary on the result shows the distribution of weights in histogram style. This information can be helpful for determining classification thresholds, e.g. by identifying clusters of record pairs with high or low weights as non-matches or matches respectively.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

This function calculates weights for record pairs based on the approach used by Contiero et al. in the EpiLink record linkage software. [Contiero et al. (2005)](http://methods.schattauer.de/en/contents/archivepremium/manuscript/431.html)

```{r}
rpairs_epiwt <- RecordLinkage::epiWeights(rpairs_jar)
```


## Manually inspect all pairs and their weights

> Discernment between matches and non-matches is achieved by means of computing weight thresholds... The most common practice is to determine thresholds by clerical review, either a single threshold which separates links and non-links or separate thresholds for links and non-links which define a range of doubtable cases between them. RecordLinkage supports this by the function getPairs, which shows record pairs aligned in two consecutive lines along with their weight.
[Sariyar & Borg, 2010](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)

Review record pairs aligned in two consecutive rows along with their weight (results hidden to protect participant privacy):

```{r}
pairs_possible_matches <- RecordLinkage::getPairs(rpairs_epiwt)
```

```{r}
pairs_possible_matches <- pairs_possible_matches %>%
  filter(id != "") %>% 
  mutate(
    dataset  = if_else(row_number() %% 2 == 1, "medstar", "client_data"),
    row      = id %>% as.character() %>% as.integer(),
    pair_num = rep(seq(nrow(.) / 2), each = 2),
    Weight   = if_else(Weight == "", lead(Weight), Weight) %>% as.character() %>% as.numeric()
  ) %>% 
  select(dataset, row, pair_num, everything(), -id) %>% 
  rename(
    "case_pcr_num" = "incident_pcr_number",
    "date"         = "date_entered"
  ) %>% 
  mutate(
    case_pcr_num = case_pcr_num %>% as.character() %>% as.numeric(),
    date         = as.Date(date)
  )
```

When the weight dips below 0.8455104, the matches begin to break down.

```{r}
max_weight <- 0.8455104 - .0001 # Because threshold below is not inclusive
```


## Keep matches

```{r}
pairs_possible_matches <- pairs_possible_matches %>% 
  filter(Weight >= max_weight)
```

[top](#top)










# Filter matches using dates {#filter-dates}

A pair should only be valid if the date in the medstar data (screening) precedes (less than or equal to) the date in the client data (APS investigation)

AND

When there is more than one date after after date in the medstar data, it is the closest in time.

Results hidden to protect patient privacy

```{r}
date_filter <- pairs_possible_matches %>% 
  group_by(pair_num) %>% 
  
  # Reshape wide to long
  mutate(
    row_client_data = row[dataset == "client_data"],
    case_num        = case_pcr_num[dataset == "client_data"],
    intake_date     = date[dataset == "client_data"]
  ) %>% 
  ungroup() %>% 
  filter(row_number() %% 2 == 1) %>% 
  
  # To be more explicit
  rename(
    row_medstar         = row, 
    incident_pcr_number = case_pcr_num,
    date_entered        = date
  ) %>% 

  # Check Medstar data precedes the date in the client data
  filter(date_entered <= intake_date) %>%
  
  # Keep earliest APS investigation
  group_by(incident_pcr_number) %>% 
  filter(intake_date == min(intake_date)[1]) %>% 
  ungroup() %>% 
  
  # Keep variables of interest
  select(starts_with("row"), pair_num)
```

[top](#top)










# Add pair numbers to nested data {#add-pair}

* Join identifiers with pair number back to nested data

* Just keep pair_num and the row identifier (incident_pcr_number/case_num). All other variables are already in the nested data frame.

```{r}
medstar_complete_w_pair <- medstar_nested %>% 
  mutate(row_medstar = row_number()) %>%
  left_join(date_filter, by = "row_medstar") %>% 
  
  # Clean up
  select(pair_num, everything(), -starts_with("row")) %>% 
  
  # Go ahead an unnest now
  unnest()
```

```{r}
client_data_w_pair <- client_data_nested %>% 
  mutate(row_client_data = row_number()) %>%
  left_join(date_filter, by = "row_client_data") %>% 
  
  # Clean up
  select(pair_num, everything(), -starts_with("row")) %>% 
  
  # Go ahead an unnest now
  unnest()
```


## Drop unneeded variables that create join conflicts below

```{r}
medstar_complete_w_pair <- medstar_complete_w_pair %>% 
  select(
    -full_name, # Just use individual name parts
    -dob        # Just use individual dob parts
  )
```

```{r}
about_data(medstar_complete_w_pair) # 63,993 observations and 56 variables
```

```{r}
client_data_w_pair <- client_data_w_pair %>% 
  select(
    -full_name, # Just use individual name parts
    -dob        # Just use individual dob parts
  )
```

```{r}
about_data(client_data_w_pair) # 752 observations and 15 variables
```

[top](#top)










# Join MedStar and APS on pair_num {#join-medstar-aps}

```{r}
medstar_aps_merged <- medstar_complete_w_pair %>% 
  full_join(
    client_data_w_pair, 
    by = "pair_num",
    suffix = c(".medstar", ".aps"),
    na_matches = "never") %>% 
  ungroup()
```


## Data Check: Join conflicts

When we join the MedStar and APS data there may be conflicts between name, DOB, age, ect. We need to investigate these conflicts and determine at least two things: 

1. Are these really matches, and 

2. Which value to keep when there are true matches with conflicting values.

Results are hidden to protect patient privacy

```{r eval=FALSE}
bfuncs::check_join_conflicts(medstar_aps_merged, suffix = c(".medstar", ".aps")) %>% # 1,728 rows
  group_by(variable, .medstar, .aps) %>% 
  filter(row_number() == 1) %>%  # 31 rows
  filter(variable == "zip")
```

### First name

* No conflicts

### Last name

* 2 conflicts

* Both are minor misspellings. In both cases, the spelling from APS appears to be the correct spelling. Keep the values from last_name.aps

### Birth month 

* No conflicts

### Birth day

* 1 conflict

* It isn't clear which one is correct. However, It doesn't affect the value for age, and we will eventually drop birth day when we deidentify the data. Therefore, it doesn't matter which one we keep.

### Birth year

* 1 conflict

* It isn't clear which one is correct. Because MedStar is our primary data source and we are interested in the medics’ assessment of the older adult/environment were the emergency response took place, we will keep the medstar row

### Age

* 1 conflict

* It isn't clear which one is correct. Because MedStar is our primary data source and we are interested in the medics’ assessment of the older adult/environment were the emergency response took place, we will keep the medstar row

### Address

* 15 conflicts

* Most of them appear to be minor spelling variations. And in cases where they are very different, there are legitimate reasons why the MedStar response address and the address where the APS investigation occured could differ.

* Because MedStar is our primary data source and we are interested in the medics’ assessment of the older adult/environment were the emergency response took place, we will keep the medstar row

### City

* 5 conflicts

* Because MedStar is our primary data source and we are interested in the medics’ assessment of the older adult/environment were the emergency response took place, we will keep the medstar row

### Zip

* 4 conflicts

* Because MedStar is our primary data source and we are interested in the medics’ assessment of the older adult/environment were the emergency response took place, we will keep the medstar row


## Resolve merge conflicts

```{r}
medstar_aps_merged <- medstar_aps_merged %>% 
  mutate(
    first_name = first_name.medstar, # No conflicts
    last_name  = last_name.aps,      # Use APS spelling
    birth_mnth = birth_mnth.medstar, # No conflicts
    birth_day  = birth_day.medstar,  # Doesn't matter
    birth_year = birth_year.medstar, # Use MedStar
    age        = age.medstar,        # Use MedStar
    address    = address.medstar,    # Use MedStar
    city       = city.medstar,       # Use MedStar
    zip        = zip.medstar         # Use MedStar
  ) %>% 
  select(-ends_with(".medstar"), -ends_with(".aps"))
```

```{r}
about_data(medstar_aps_merged) # 64,837 observations and 61 variables
```

[top](#top)










# Check incident call numbers reported to MedStar compliance {#check-response}

Check to see if the expectd response numbers from the MedStar compliance data exist in the merged data. 

In data_medstar_detect_screenings_01_import.Rmd there were 8 response id's from the compliance data that had a match in the DETECT screening tool data.

```{r}
about_data(response_ids) # 14 observations and 1 variables
```

anti_join returns all rows in MedStar's legal compliance data that do not have a match in the MedStar DETECT screening items data that was matched to APS cases (results hidden to protect participant privacy).

```{r eval=FALSE}
response_ids %>% 
  anti_join(medstar_aps_merged %>% 
              group_by(incident_pcr_number) %>% 
              filter(row_number() == 1), 
            by = c("response_num" = "incident_call_number")) %>%  
  unique() # 6 incident call numbers
```

There arere 6 responses id's in the MedStar compliance data that don't appear in the MedStar DETECT screening items data (results hidden to protect participant privacy). 

I have an email from MedStar from 2016-10-10 outlining the discrepancy. One response id had all nulls for the DETECT screening items (...147). One response id could not be found in the query. The rest were ineligible for the DETECT screening tool because of age.

At this point, there should be 8 response id's from the compliance data that have a match in the complete MedStar data (results hidden to protect participant privacy).

```{r eval=FALSE}
response_ids %>% 
  semi_join(medstar_aps_merged %>% 
              group_by(incident_pcr_number) %>% 
              filter(row_number() == 1), 
            by = c("response_num" = "incident_call_number")) %>% 
  unique() # 8 incident call numbers
```

[top](#top)










# Save the merged MedStar datasets {#save}

```{r}
feather::write_feather(medstar_aps_merged, path = "/Volumes/Detect/medstar_aps_merged.feather")
```

## References 

Contiero, P., Tittarelli, A., Tagliabue, G., Maghini, A., Fabiano, S., Crosignani, P., & Tessandori, R. (2005). The EpiLink Record Linkage Software Presentation and Results of Linkage Test on Cancer Registry Files. Methods Archive, 44(1), 66-71.

Sariyar, M., & Borg, A. (2010). The RecordLinkage package: Detecting errors in data. The R Journal, 2(2), 61-67.

Winkler, W. (1990). String comparator metrics and enhanced decision rules in the Fellegi-Sunter model of record linkage. Available from http://eric.ed.gov/?id=ED325505.

[top](#top)

&nbsp;

-------------------------------------------------------------------------------

```{r echo=FALSE}
sessionInfo()
```