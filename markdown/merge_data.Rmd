---
title: "Merge MedStar and APS Data"
date: "`r Sys.Date()`"
output: 
  html_notebook:
    toc: true
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    css: custom-css.css
---

-------------------------------------------------------------------------------

# Load packages and functions

```{r load_packages, message=FALSE}
# CRAN packages
library(tidyverse)
library(lubridate)
library(RecordLinkage)
library(stringr)
library(zoo)

# devtools::install_github("mbcann01/dataclean")
library(dataclean) 
# Use this instead of str() to prevent showing raw data values
```

# Load data

```{r load_data}
load("/Users/bradcannell/Desktop/medstar.RData")
load("/Users/bradcannell/Desktop/client_data.RData")
```

# Linkage Preprocessing

Create two new data sets (client data compare and medstar compare) that contain only the subset of variables we want to use for linking records between MedStar and APS (i.e., first name, last name, birthdate)

```{r preprocessing}
# Decompose dates
# Select variables and variable order
client_data_compare <- client_data %>%
  mutate(
    birth_mnth = month(dob),
    birth_day  = day(dob),
    birth_year = year(dob)) %>%
  select(first_name, last_name, birth_mnth:birth_year)

medstar_compare <- medstar %>%
  mutate(
    birth_mnth = month(dob),
    birth_day  = day(dob),
    birth_year = year(dob)) %>%
  select(first_name, last_name, birth_mnth:birth_year)
```

-------------------------------------------------------------------------------









# Add string comparitors

## Jarowinkler

[(Winkler, 1990)](http://eric.ed.gov/?id=ED325505)

```{r jarowinkler}
rpairs_jar <- compare.linkage(client_data_compare, medstar_compare,
                              strcmp = c("first_name", "last_name"),
                              strcmpfun = jarowinkler)
summary(rpairs_jar)
rpairs_jar$frequencies
```

Compares each record in data set 1 to each record in data set 2 until all records are compared. For example, id1 - id1, id1-id2, idn-idm. For each pair, a probability match is given for each variable (i.e., first name, last name, etc.)

-------------------------------------------------------------------------------

## Stochastic record linkage

[Contiero et al. (2005)](http://methods.schattauer.de/en/contents/archivepremium/manuscript/431.html)

```{r epi_weights}
rpairs_epiwt <- epiWeights(rpairs_jar)
summary(rpairs_epiwt)
```









## People with multiple records

Now, given the probability matches for each variable, we're given computed weights (derived from probabilities) of records being a match. Again, this is for id1-id1, id1-id2, idn-idm.

These records are based on name and dob. However, if a given person is in the MedStar data more than once, which APS record would it match with?

Are any names in the MedStar data more than once?

```{r}
# There are 1247 rows in the MedStar data
length(unique(medstar$full_name))
```

Some names are in the data more than once. Take a look at these rows

```{r}
# index <- which(duplicated(medstar$full_name))
# names <- medstar$full_name[index]
# check <- medstar[medstar$full_name %in% names, ]
# check[order(check$full_name), ]
# rm(index, names, check)
```

-------------------------------------------------------------------------------

Get pairs

Shows record pairs aligned in two consecutive lines along with their weight.

```{r get_pairs, results='hide'}
weighted_pairs <- getPairs(rpairs_epiwt, max.weight = Inf, min.weight = 0.5)
# weighted_pairs
# Results hidden to protect participant privacy
```

When the weight dips below 0.7 or so, the matches begin to break down.

-------------------------------------------------------------------------------

## Classification

```{r classification}
result <- epiClassify(rpairs_epiwt, 0.7)
```

> The result is an object of class "RecLinkResult", which differs from the data object in having a component prediction that represents the classification result. Calling summary on such an object shows error measures and a table comparing true and predicted matching status [(Sariyar & Borg, 2010)](https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Sariyar+Borg.pdf).

```{r result}
summary(result)
```

-------------------------------------------------------------------------------









# Merge classification info with original data frames   

Previously, we created two new data sets (client data compare and medstar compare) that contained only the subset of variables we wanted to use for linking records between them. Now that we have an Identifier that links the records, we want to merge it with the original data sets (client data and medstar), which contain the variables that we are actually interested in.

* Filter for the pairs that were classified as [possible] links, "L".   

* Remember that aps client data is data1 (first row in pair of rows), and MedStar data is data2 (second row in pair of rows).  

* The _id_ numbers in the data below are generated automatically by the RecordLinkage package. They have no relationship to the original data.

```{r show_L_matches}
results_l <- result[result$prediction == "L"]
pairs_l <- getPairs(results_l)
cat("Done")
```

```{r}
# Drop blank rows that are used as separators
pairs_l <- pairs_l[pairs_l$id != "", ]
cat("Done")
```

```{r}
# Renumber rows sequentially
rownames(pairs_l) <- seq(1:nrow(pairs_l))
cat("Done")
```

```{r}
# Create a new variable that corresponds to the row number
pairs_l$row <- as.numeric(rownames(pairs_l))
# head(pairs_l)
cat("Done")
```

```{r}
# Create pair number for each pair of potentially matching rows
pairs_l$group <- rep(seq(1, nrow(pairs_l) / 2), times = 1, each = 2)
# head(pairs_l)
cat("Done")
```

## Coerce variables from factor to numeric/character as appropriate  

```{r id_to_num}
pairs_l <- pairs_l %>%
  map_at(
    .at = c("id", "birth_mnth", "birth_day", "birth_year", "Weight"),
    .f = ~as.numeric(as.character(.))) %>%
  map_at(
    .at = c("first_name", "last_name"),
    .f = as.character)%>% 
  as_tibble
# head(pairs_l)
cat("Done")
```

## Merge the APS client data with every odd row in pairs\_l, matching pairs\_l$id with the rownumber in client\_data

```{r merge_aps_client_data}
# Subset odd rows from pairs_l
pairs_l_aps <- pairs_l[pairs_l$row %% 2 == 1, ]
cat("Done")
```

```{r}
# Create id variable in client data for matching with id variable in pairs_l_aps
client_data$id <- as.numeric(rownames(client_data))
cat("Done")
```

```{r}
# Drop varible names that will conflict during merge (e.g. "case_num.x"")
client_data <- client_data %>% 
  select(case_num:full_name, age:id)

pairs_l_aps <- left_join(pairs_l_aps, client_data, by = "id")
cat("Done")
```

## Merge the DETECT screening data with every even row in pairs\_l, matching pairs\_l$id with the rownumber in medstar

```{r merge_medstar_data}
# Subset odd rows from pairs_l
pairs_l_med <- pairs_l[pairs_l$row %% 2 == 0, ]
cat("Done")
```

```{r}
# Create id variable in medstar for matching with id variable in pairs_l_med
medstar$id <- as.numeric(rownames(medstar))
cat("Done")
```

```{r}
# Drop varible names that will conflict during merge
medstar <- medstar %>% 
  select(response_num:adls61, id)

pairs_l_med <- left_join(pairs_l_med, medstar, by = "id")
cat("Done")
```

Right now, id is just the row that particular 911 response happened to occupy in the MedStar data, and the row that the investigation happened to occupy in the APS data.

Currently, each person has at least two id numbers associated with them (one that is equal to the MedStar row, and one that is equal to the APS row). Obviously, if they appear in either data frame more than once, then they will have more than 2 id numbers.

-------------------------------------------------------------------------------









# Check response numbers against response numbers reported to compliance

Check to see if all the response numbers from the MedStar compliance data exist in the current data.   

```{r}
# These response id's are from the data sent to me by MedStar compliance
load("/Users/bradcannell/Desktop/response_ids.RData")
cat("Done")
```

```{r}
# Convert response_ids and pairs_l_med$response_num to atomic vectors
ri <- unlist(response_ids)
rn <- unlist(pairs_l_med$response_num)
cat("Done")
```

```{r}
# Check for rows that appear in ri, but not rn
no_match <- dplyr::setdiff(ri, rn)
length(no_match)
```

```{r}
# Save the 8 remaining id's
match_ids <- dplyr::intersect(ri, rn)
length(match_ids)
```

There are 7 response numbers in the MedStar compliance data that don't appear in the MedStar DETECT screening items data. I have an email from MedStar from 2016-10-10 outlining the discrepancy. One response id had all nulls for the DETECT screening items. One response id could not be found in the query. The rest were ineligible for the DETECT screening tool because of age.

There's an additional response number (8 total) that doesn't appear in the data that was paired with APS data. I assume it's because the record in the MedStar data with that response number, had no match in the APS data. I check this assumption below.

## What is the 8th non-matching response number?

```{r}
# Convert medstar$response_num to atomic vectors
mrn <- unlist(medstar$response_num)
cat("Done")
```

```{r}
# Check for rows that appear in ri, but not mrn
not_mrn <- dplyr::setdiff(ri, mrn)
length(not_mrn)
```

```{r}
# Check for response numbers that appear in no_match (difference between compliance data and paired MedStar data) and not_mrn (difference between compliance data and entire MedStar DETECT data)
check_id <- dplyr::setdiff(no_match, not_mrn)
cat("Done")
```

## What is the name and birthdate associated with that response number?

```{r}
# medstar %>% 
#   filter(response_num == check_id) %>% 
#   select(response_num, full_name, dob)

# Hidden to protect privacy
```

## Search the APS to confirm that it doesn't contain a record for that person

```{r}
# client_data_compare %>% 
#   filter()

# Search criteria deleted to protect privacy.  
```

I checked first name, last name, and birth year manually for close matches. That person does not appear to be in the APS data. So, there are 8 response numbers from the compliance data that have a match in the DETECT screening tool data. Alternatively, there are also 8 response numbers from the compliance data that do not have a match in the DETECT screening tool data.

## Create a dummy variables indicating that response number matches a response number from the compliance data

```{r}
pairs_l_med <- pairs_l_med %>%
  mutate(
    compliance_match = if_else(response_num %in% match_ids, 1L, 0L, NA_integer_),
    compliance_match = factor(compliance_match, labels = c("No", "Yes"))
  )
cat("Done")
```

```{r}
# Data checking
table(pairs_l_med$compliance_match)
# pairs_l_med$response_num[pairs_l_med2$compliance_match == 1]
# unique(pairs_l_med$response_num[pairs_l_med$compliance_match == 1])
# Hidden to protect privacy
```

There are 12 rows in the new linked medstar data with a response number that matches a response number in the data we got from compliance. However, there are only 8 unique response numbers (as expected). We filter out duplicates below.

```{r}
# Clean up
rm(ri, rn, no_match, mrn, not_mrn, check_id)
```

-------------------------------------------------------------------------------








# Appending the MedStar and APS data back together

## Append pairs\_l\_med to pairs\_l\_aps, and then sort by row.

```{r append_pairs}
pairs_l_bind <- bind_rows(pairs_l_aps, pairs_l_med)
pairs_l_bind <- pairs_l_bind[order(pairs_l_bind$row), ]
about_data(pairs_l_bind) # 264 observations and 50 variables in the data 
```

## Set all NULL values to NA   

```{r to_na}
pairs_l_bind <- pairs_l_bind %>%
  # Null to NA
  map_if(.p = is.character, 
         .f = function(x) {
           x[x == "NULL"] <- NA 
           return(x)}) %>%
  as_tibble()
cat("Done")
```

## Share info between rows (between the MedStar and APS data)

1. Carry forward APS info into the even (medstar info) rows    
2. Carry backward medstar response date   

```{r carry_forward}
# Were there any missing to worry about?
sum(is.na(client_data$case_num))
sum(is.na(client_data$intake_stage))
sum(is.na(client_data$intake_start))
sum(is.na(medstar$response_date))
# No missing - perform na.locf
```

```{r}
pairs_l_bind <- pairs_l_bind %>% 
  map_at(
    .at = c("case_num", "intake_stage", "intake_start", "county"), 
    .f = zoo::na.locf
  ) %>%
  map_at(
    .at = c("Weight", "response_num", "response_date", "compliance_match"), 
    .f = zoo::na.locf, fromLast = TRUE
  ) %>%
  as_tibble()
cat("Done")
```

## Manually inspect all pairs with weight < 1.0 (Not a perfect match)

```{r manual_inspect, results='hide'}
# Carry Weight value backward to previous row
pairs_l_bind$Weight <- zoo::na.locf(pairs_l_bind$Weight, fromLast = TRUE)

# View(filter(pairs_l_bind, Weight < 1))
# Results hidden to protect participant privacy
cat("Done")
```

After manual inspection, the last true match has a weight of 0.8320895. Will drop all rows with a weight < 0.8320895.

```{r drop_weight}
pairs_l_bind <- filter(pairs_l_bind, Weight >= 0.8320895)
about_data(pairs_l_bind) # 182 observations and 50 variables in the data 
```

## How many DETECT screenings have a match in the APS outcomes data?

```{r}
pairs_l_bind %>% 
  filter(row_number() %% 2 == 1) %>% # Keep only the MedStar rows
  distinct(id) %>% 
  nrow()
```

How many compliance matches remain?

```{r}
pairs_l_bind$aps_report_num %>% unique() %>% length()
# table(pairs_l_bind$aps_report_num, useNA = "always")
table(pairs_l_bind$compliance_match)
```

The 8 report numbers and NA.

## Reporting order

response\_date is when MedStar responded to the 911 call. intake\_start is when APS started the intake. Logically, the response\_date must be before the intake\_start in order for the DETECT tool to have predicted abuse.

Take a look at matches where the opposite is true.

```{r view_dates, results='hide'}
temp <- filter(pairs_l_bind, response_date > intake_start)
# View(temp)
# Results hidden to protect participant privacy
cat("Done")
```

## Check response numbers

Check to see if any of the response numbers from the MedStar compliance data exist in the data that will be dropped. 

```{r}
intersect(response_ids, temp$response_num) %>% length()
```

None of the response id numbers from the MedStar compliance data are among the records that will be dropped because of reporting order. I also checked the data manually. aps_report_num is NA in all rows of temp.

## Drop pairs when MedStar response date is after APS intake date   

```{r drop_dates}
# Updated on 2017-01-28: changed from response_date < intake_start to response_date <= intake_start. Remember, intake_start is just APS receiving a report.
pairs_l_bind <- filter(pairs_l_bind, response_date <= intake_start)
about_data(pairs_l_bind) # 112 observations and 50 variables in the data
```

How many compliance matches remain?

```{r}
pairs_l_bind$aps_report_num %>% unique() %>% length()
```

## Time to intake

Calculate time between response date and intake

```{r time_diff}
pairs_l_bind$time_diff <- difftime(pairs_l_bind$intake_start, pairs_l_bind$response_date, units = "days")
cat("Done")
```

## Create two new variables to retain the MedStar and APS ID's

In the past I dropped these. Decided to keep them in order to better understand where the rows in my final analysis come from.

```{r}
pairs_l_bind <- pairs_l_bind %>% 
  group_by(group) %>% 
  mutate(
    msid  = ifelse(row %% 2 == 0, id, NA),
    apsid = ifelse(row %% 2 == 1, id, NA),
    msid  = zoo::na.locf(msid, fromLast = TRUE),
    apsid = zoo::na.locf(apsid)
  ) %>% 
  ungroup()

# Data check
# select(pairs_l_bind, id, first_name, msid, apsid)

# Double-checked. msid and apsid were carried forward correctly. I also checked to make sure that the do, in fact, correspond the the row numbers of the original medstar and client_data data frames. They do. 
cat("Done")
```

```{r}
# Drop the id column and move msid and apsid to the front of the tibble
pairs_l_bind <- pairs_l_bind %>% 
  mutate(
    id = NULL
  ) %>% 
  select(
    msid, apsid, row, group, everything()
  )

# Data check
# head(pairs_l_bind)
about_data(pairs_l_bind) # 112 observations and 52 variables in the data
```

## Collapse rows

Even rows (MedStar rows) contain all the APS information. So, just keep the even rows.

```{r keep_even}
pairs_l_bind <- pairs_l_bind[pairs_l_bind$row %% 2 == 0, ]
about_data(pairs_l_bind) # 56 observations and 52 variables in the data 
```

## Make sure that each row is unique to a person / DETECT screening date

### Case number definition

APS case / investigation number.

### Intake stage definition

That's an ID number assigned to the Intake. Each Intake (Report to APS) has its own number. A case may have more than one intake. For example, on the first tab of the spreadsheet, you can see that case # XXXXXX has two intakes associated with it, 9 days apart, each with their own ID number. On the second tab of the spreadsheet, which provides allegations associated with each intake, you can see that each of the two intakes associated with this case have a number of allegations.

### Intake start definition

An intake is the submission or receipt of a report of abuse - a phone call or web-based The Intake Start Date refers to the date the staff member opens a new record to begin recording the report. In the case of a phone call they have picked up from a caller on the abuse hotline, the intake starts when the Intake worker begins to speak to the individual, open the record and begin recording what they are hearing. In the case of reports made using the web-based system, intake begins when the Intake worker pulls the web-report and begins processing it in the system. There is the possibility that the intake may begin on one day but not end until the next day.

### Response number definition

From MedStar: There is incident and response number. Incident is one incident. Response is unique to patient/truck.

### Response date definition

Day that MedStar ran the 911 call and filled out the DETECT screening tool.

If a row is unique to a person / DETECT screening date, then the combination of first/last name and response date should be unique.

```{r check_unique, results='hide'}
pairs_l_bind <- pairs_l_bind %>% 
  mutate(
    compare = paste(first_name, last_name, response_date)
  )

sum(duplicated(pairs_l_bind$compare)) # 10
```

There are 10 rows with a duplicate (20 rows total) in terms of first/last name and response date. Investigate these manually.

```{r}
# Grab duplicate index
index <- duplicated(pairs_l_bind$compare)

# Grab values of compare at duplicate indices
index <- pairs_l_bind$compare[index]

# View all rows with those values
temp <- pairs_l_bind %>%
  filter(compare %in% index) %>%
  select(msid:group, compare, time_diff, aps_report_num, compliance_match, everything()) %>%
  arrange(compare)
# View(temp)
# Results hidden to protect participant privacy
```

### Rules for dropping duplicates

In this context, duplicates are in terms of person and response date (date DETECT screening tool was used). These may arise for a number of reasons. In general, we have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, our goal is to retain one row for each DETECT screening, and pair it with the corresponding APS investigation (on the same person, of course) that was temporally closest to the screening.

1. If two DETECT screenings are completed for the same person in a single day, then that person will have two records in the MedStar data with identical response dates. However, they aren't really duplicates. They are two different screenings, potentially completed by two different people. The predictive performance of both screenings should be analyzed.

2. For any given screening in the MedStar data that was matched to multiple investigations (on the same person, of course) in the APS data, we keep the row with the shortest amount of time between screening and intake_start.

3. When two rows differ only by intake stage, it means that there was one MedStar screening and one APS investigation, but the investigation was prompted by two or more separate reports. Therefore, one row is simply duplicate information, and retain both would essentially up weight the influence of that particular screening / outcome combination. Choosing the row to drop is arbitrary. For consistency, we will always drop the second row.

#### Application of the dropping rules in this data

* Rows 4 and 6 only differ by intake stage. Row 6 will be dropped.

* For rows 112 and 126 one DETECT screening was matched with two different APS investigations. We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 126.

* For rows 110 and 124 one DETECT screening was matched with two different APS investigations. We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 124.

* Rows 84 and 86 only differ by intake stage. Row 86 will be dropped.

* Rows 8 and 10 only differ by intake stage. Row 10 will be dropped.

* For rows 88 and 156 one DETECT screening was matched with two different APS investigations. We have no way of knowing which (if any) investigation was truly a result of DETECT. Therefore, in cases like this we will keep the row with the shortest amount of time between screening and intake start. In this specific case we will drop row 156.

* Rows 134 and 136 only differ by intake stage. Row 136 will be dropped.

* Rows 106 and 108 only differ by intake stage. Row 108 will be dropped.

* Rows 114, 116 and 118 only differ by intake stage. Rows 116 and 118 will be dropped.

### Drop duplicate rows and the compare variable

```{r}
drop <- temp %>% 
  group_by(compare) %>% # Within "compare" group
  arrange(compare, time_diff, intake_stage) %>% # sort by time_diff and, if tied, by intake stage
  filter(!(row_number() == 1)) %>%  # Select all but the first row in each group
  ungroup %>% 
  select(row) %>% # Just return the values of the variable row
  unlist # Turn into a vector
```

```{r}
# Remove observations from pairs_l_bind with a value of row that is included in "drop"
pairs_l_bind <- pairs_l_bind %>% 
  filter(!(row %in% drop)) %>% 
  select(-compare)
about_data(pairs_l_bind) # 46 observations and 52 variables in the data
```

## Final manual inspection   

1. Visually inspect rows for a match   
2. Make sure that each pair is unique to a person / DETECT screening date 

```{r final_manual_inspection, results='hide'}
# View(pairs_l_bind)
# Results hidden to protect participant privacy
```

There are still people who appear in the data more than once. However, they these people have a separate DETECT screening associated with each of their records. 

We don't know which DETECT screening (if any) was the cause of the APS investigation it's being linked with. Currently, this isn't really an issue because we aren't using this data to determine if DETECT is increasing reports or not. We are getting that information from MedStar compliance. With this data, we are simply evaluating whether or not a "yes" response on any given screening is predictive of a valid investigation - regardless of the report that initiated it.

The data we currently have meets that criteria. We have a completed DETECT screening. That DETECT screening is paired with an APS investigation for the same person, which was carried out shortly after the DETECT screening occurred.

It's still possible that our analysis data could be dominated by results from just a handful of people. We will have to check the records we end up using in the final analysis.

```{r}
# Are all 8 of the compliance cases still in the data?
pairs_l_bind$aps_report_num %>% unique() %>% length() # The 8 reports and NA
```

8 reports (and NA) from the compliance data remains in the data. 

```{r clean, echo=FALSE, results='hide', warning=FALSE}
# Clean up
rm(client_data_compare, medstar_compare, pairs_l, pairs_l_aps, pairs_l_med, weighted_pairs, drop, result, results_l, rpairs, rpairs_epiwt, rpairs_jar, rpairs_lev, temp, response_ids, index, match_ids)
```









-------------------------------------------------------------------------------

# Merge with other APS data

```{r load_other_aps_data}
# Load cleaned APS data
load("/Users/bradcannell/Desktop/allegations.RData") # Allegations
load("/Users/bradcannell/Desktop/closure.RData")     # Closure Reason
load("/Users/bradcannell/Desktop/disposition.RData") # Disposition

# For easier visual inspection, just keep the case numbers of interest
keep <- unique(pairs_l_bind$case_num)

allegations <- filter(allegations, case_num %in% keep)
closure     <- filter(closure, case_num %in% keep)
disposition <- filter(disposition, case_num %in% keep)

rm(keep)
```

First, we filtered out case numbers that didn't match case numbers in the linked records data (41 unique case numbers). 

Before merging there were 56 rows in the allegations data, 42 rows in the closure data, and 51 rows in the disposition data. Some cases include more than one allegation. They may also include multiple intakes/reporters, and perpetrators. 

After visual inspection of the data:   
1. Allegations contains a row for each combination of case number, intake stage (reporter), allegation and perpetrator.    
2. Disposition contains a row for each combination of case number, allegation, and perpetrator, but does not differentiate between intake stage numbers (reporter).     
3. Closure contains a row for each combination of case number and intake stage; however, the actual closure reason is constant across rows within case number.    

For the purposes of the current analysis we aren’t so concerned with who reported the abuse. Ultimately, we do want EMTs to report more often when appropriate; however, the aim of the current analysis is just to investigate the predictive performance of the screening items. We are just concerned with whether or not the tool accurately predicted abuse - regardless of who reported it.

Therefore, we will drop all rows in allegation that only differ by intake stage. This will make for a cleaner merge below.

```{r}
# Drop intake_stage and perp_id
allegations <- select(allegations, case_num, allegation, perp)

# Remove duplicate rows
allegations <- distinct(allegations)
about_data(allegations) # 57 observations and 3 variables in the data
```

After dropping duplicate rows there are 48 observations and 3 variables in the data 

## Allegations at intake vs. allegations at investigation

APS writes of the difference between allegation at intake (in the allegations file) and allegations at investigation (in the disposition file):

> At the time of intake, the intake worker will listen to the allegations and categorize them based on what they are hearing from the caller. Once the investigator gets involved and begins work on the case, they may revise or more often add to the allegations as they flesh out the situation. As they investigate, they often discover new allegations relevant to the case. There has to be a unique allegation for every perpetrator, so as the investigation proceeds and more than one perpetrator may be involved (including self-- very often both self-neglect and ANE by another are co-occurring), the number of allegations per case can multiply.

Next, we will check to make sure that all allegations (at intake and at investigation) are retained, and that they have a corresponding disposition and closure reason.

```{r merge_check}
check <- left_join(allegations, disposition, by = c("case_num"))

# Are there any cases of an allegation/perpetrator in allegation.x/perp.x that doesn't exist in allegation.y/perp.y?
check2 <- check %>% 
  group_by(case_num) %>%
  mutate(
    combox = paste0(allegation.x, perp.x),
    comboy = paste0(allegation.y, perp.y),
    xiny   = ifelse(combox %in% comboy, TRUE, FALSE)
  )

# All say true. Just to make sure it's doing what I think it should be doing, I'm going to embed a fake value.
# check3 <- check
# check3[4, 2] <- "Exploitation" 
# check4 <- check3 %>% 
#   group_by(case_num) %>%
#   mutate(
#     combox = paste0(allegation.x, perp.x),
#     comboy = paste0(allegation.y, perp.y),
#     xiny   = ifelse(combox %in% comboy, TRUE, FALSE)
#   )
# Works as expected
rm(check, check2)
cat("Done")
```

After data checks:   
1. Must do a left_join on case number only. Otherwise, allegations at investigation (from disposition) are lost.     
2. After left join, allegation.x and perp.x no longer contain any unique information and can be dropped.    
3. Finally, we need to clean up the data by renaming allegation.y and perp.y, and dropping duplicate rows.

## Merge [allegations](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_1340.asp#APS_1340) and [disposition](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2700.asp#APS_2700)

```{r merge_allegations_disposition}
ad <- left_join(allegations, disposition, by = c("case_num")) %>%
  mutate(
    allegation.x = NULL, 
    perp.x = NULL) %>%
  rename(
    allegation = allegation.y,
    perp = perp.y) %>%
  distinct
about_data(ad) # 61 observations and 5 variables in the data 
```

After merging there were 61 observations and 5 variables in the data.

## Merge with [closure reason](http://www.dfps.state.tx.us/handbooks/APS/Files/APS_pg_2800.asp#APS_2900)

```{r merge_with_closure}
# Remove intake stage
closure <- closure[, -2]

# Remove duplicate rows (There is only one closure reason per case number)
closure <- distinct(closure)

# Join
adc <- left_join(ad, closure, by = "case_num")
about_data(adc) # 61 observations and 6 variables in the data
```

After merging there were 61 observations and 6 variables in the data.

## Merge with linked MedStar and client data

In some cases there are multiple rows per case number. In all of those cases it's because of differing response numbers / dates. In other words, MedStar completed DETECT on a person more than once, but they were close enough to each other in time, that APS only performed one investigation. In those cases, we will keep both rows.

```{r merge_with_medstar}
merged <- left_join(pairs_l_bind, adc, by = "case_num")
# Look for duplicate rows
sum(duplicated(merged))
# None
```

```{r}
about_data(merged) # 67 observations and 57 variables in the data
```

After merging there were 67 observations and 57 variables in the data.

```{r}
# Total unique person / date combinations
# Should be the same as pairs_l_bind before merging with the APS data.
length(unique(merged$group)) # 46
```

```{r}
about_data(merged) # 67 observations and 57 variables in the data
```

```{r}
# Are all 8 of the compliance cases still in the data?
merged$aps_report_num %>% unique() %>% length() # The 8 reports and NA 
```

```{r}
# Clean up
rm(ad, adc, allegations, client_data, closure, disposition, medstar, pairs_l_bind)
```

-------------------------------------------------------------------------------

&nbsp;






# Coerce selected character vectors to factors   

To improve readability of codebook

```{r to_factor}
merged <- merged %>%
  map_at(
    .at = c("msid", "apsid", "row", "group", "birth_month", "birth_day", "birth_year", "Weight", 
            "case_num", "intake_stage", "zip", "response_num", "response_date", "aps_report_num", 
            "allegation", "perp", "disposition", "closure_reason"),
    .f = factor
  ) %>%
  as_tibble
cat("Done")
```

-------------------------------------------------------------------------------

# Save data
```{r save}
write_rds(merged, path = "/Users/bradcannell/Desktop/merged.RData")
cat("Done")
```

-------------------------------------------------------------------------------

# References

Contiero, P., Tittarelli, A., Tagliabue, G., Maghini, A., Fabiano, S., Crosignani, P., & Tessandori, R. (2005). The EpiLink Record Linkage Software Presentation and Results of Linkage Test on Cancer Registry Files. Methods Archive, 44(1), 66-71.

Sariyar, M., & Borg, A. (2010). The RecordLinkage package: Detecting errors in data. The R Journal, 2(2), 61-67.

Winkler, W. (1990). String comparator metrics and enhanced decision rules in the Fellegi-Sunter model of record linkage. Available from http://eric.ed.gov/?id=ED325505.

-------------------------------------------------------------------------------

#### Session Info
```{r session_info, echo=FALSE}
sessionInfo()
```
